\section{Introduction}
\label{sec.introduction}

For many years system designers and developers have had to deal with a common security issue --
how to defend against threats hidden within the system's own code. Despite
 decades of effort, researchers still frequently uncover new flaws in operating
 system kernels. Such interactions
are dangerous because, if triggered by
interaction with untrusted programs, these
bugs can lead to security threats like privilege escalation
 [CVE-2016-0728], [CVE-2015-8660], denial of service [CVE-2015-8539], [CVE-2015-5364],
  and memory corruption [CVE-2014-9529].

The search for an ideal way to protect this code has been hampered by limited
knowledge of the security impact of its interaction with user programs.
A number of strategies have been tried. One prevailing belief was that virtual
machines could provide enough isolation to execute programs safely.
However, when Virtualbox reports 40 vulnerabilities \cite{Virtualbox-Vulnerabilities},
 and more than 100 bugs have been found in VMware Workstation
it suggests that isolation alone may not be enough. Other researchers have looked
 to the development of
 metrics capable of pinpointing bugs, and, therefore, securing the most
 vulnerable areas.\cite{PittSFIeld, ozment2006milk} As these examples indicate, the design of
 secure systems has been somewhat “hit-or-miss.” Observations may lead to
 the reduction of specific threats, but not to a reproducible, broadly applicable,
quantitative design solution.

With this paper, we move one step closer to that goal. We start with the proposition
 that code found in popular paths, associated with frequently-used programs,
has less potential risk of bugs than code in less-used parts of the kernel.
Therefore, we should be able to determine which lines of code can be executed
 safely within the OS kernel. We performed a quantitative analysis of resilience
  to flaws in two versions of the Linux kernel, and
found that only 2.5\% - 4.0\% of the bugs were present in popular code paths,
despite these paths accounting for nearly 32.2\% - 34.5\% of the total reachable kernel code.
When we ran the same study on the same Linux kernel versions using two other metrics
(Chou \cite{PittSFIeld} and Ozment \cite{ozment2006milk}),
we found them less effective at predicting the location of zero-day bugs in the
Linux kernel versions that we tested.

Guided by this knowledge, we propose a new design scheme for a secure virtual machine that
accesses only the popular code paths through a very small trusted computing base.
Named \emph{Lock-in-Pop}, because it locks out kernel access to all code except
that found in paths associated with frequently-used popular programs, the scheme
 requires an interface built only on basic OS primitives. This is sufficient to
  perform operations for file systems, such as
networking, threading, and memory management, and other required functions.
For complex functionalities,  \emph{Lock-in-Pop}, re-creates system calls in
a memory-safe programming language sandbox.

To demonstrate the viability of \emph{Lock-in-Pop} we use it to implement a new
prototype virtual machine that can offer enhanced security without sacrificing
 basic functionality. Dubbed Lind, it pairs two components -- Google's Native Client
(NaCl) and Seattle's Repy. NaCl serves as a computational module that isolates
binaries, providing memory
safety for a legacy program like Apache. It also passes system calls invoked by
 the program to the operating system interface,called SafePOSIX. This interface,
  isolated within the Repy
sandbox, ensures access to only popular paths, while the small (8K LOC) sandbox
 kernel allows complex operating system functionalities to be built on top of the machine.

To test Lind's effectiveness, we replicated 35 kernel bugs in the Linux kernel
version 3.14.1,
and attempted to trigger them in seven other virtualized environments,
including VirtualBox, VMWare Workstation,
Docker, LXC, KVM, QEMU, and Graphene.
Our results show that applications in Lind were least likely to trigger kernel bugs,
with only one out of the 35 (2.9\%) kernel vulnerabilities tested for being triggered.

In summary, the main contributions of this paper are as follows:

\begin{itemize}\setlength\itemsep{0em}
\item
We postulate a new approach for securing privileged code,
such as the OS kernel, based on the idea that popular kernel paths contain fewer bugs.

\item
We propose a quantitative metric that evaluates security
 at the lines-of-code level.
After testing this metric against others, we find it effective in locating
 bugs in the Linux kernel.

\item
Based on the metric, we develop a new design scheme called \emph{Lock-in-Pop} that
accesses only popular code paths
through a very small trusted computer base.
The need for complex functionality is addressed by re-creating riskier systems calls
in a memory-safe programming language within a secure sandbox.

\item
We build a prototype virtual machine, Lind, using the \emph{Lock-in-Pop} principles,
 and test its effectiveness against seven other security systems. We find that
 Lind triggers only one
(2.9\%) of the 35 zero day bugs we had targeted,
making it an order of magnitude more secure than other systems.
\end{itemize}

%\yiwen{Can we lose the last map paragraph? I'd like to remove it and it will save a lot of space.}
%
%The remainder of this paper is organized as follows.
%Section \ref{sec.motivation-and-background} presents the scope of our study and our threat model.
%A study of earlier kernel protection metrics and the results of tests we ran to compare their performance
%against our newly proposed design are discussed in Section \ref{sec.metric}.
%Section \ref{sec.design} describes the development of our \emph{Lock-in-Pop} design scheme.
%In Section \ref{sec.implementation} we discuss the construction of the Lind prototype,
%while Section \ref{sec.evaluation} provides the  results of tests that directly compare Lind's performance
%in preventing the triggering of bugs to other virtualization systems.
%Section \ref{sec.limitation} outlines possible future initiatives.
%Finally, Section \ref{sec.related_work} reviews existing design metrics, as well as techniques that share some of Lind's security techniques and goals,
%while the cogent points relayed in the paper are reviewed in Section \ref{sec.conclusion}.
