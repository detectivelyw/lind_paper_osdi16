\section{Goals and Threat Model}
\label{sec.motivation-and-background}

\textbf{Goals.}
Our goal is to design and build secure virtualization systems that allow
untrusted programs to run on an unpatched and vulnerable host OS (Linux OS in
 this study), without triggering vulnerabilities that attackers could exploit.
 Developing effective defenses for the host OS is essential as this code
 can provide attackers access that could lead to a system take-over.
 \yanyan{what are the other parts of the system?}\lois{I just re-wrote the
 opening. Hope this eliminates the questions.}
To combat this threat, untrusted programs are often executed in a secure
 virtualization system, such as a guest OS VM, a system call interposition
 module, or a library OS. The goal of the study documented in this paper is to
build such a security virtualization system capable of protecting not only the
an underlying host OS, but also programs running on it, from both malicious attacks
and accidental triggering from application system calls. However, as we will document
 in Section 3, there have been a number of approaches to designing such a system.
In this section, we define the scope of our design approach, including some basic
assumptions about the level of security that we intend to enforce,
and the possible attacks that we desire to protect against. We also briefly note
a few existing design schemes we chose to exclude from this study and why.

In our study, we acknowledge that an attack on the host OS could be staged in our secure
virtualization system. The security goal is to prevent a potential outcome of such
an attack: the exploitation of an unpatched vulnerability. Furthermore, we
anticipate that such an exploit could be done directly, by performing an action in the
virtualization system, or indirectly by causing a vulnerability to escape the
containment of the virtualization system. \yanyan{maybe explain what is to escape
its containment?} In the former case, the attacker is
taking advantage of the secure system by utilizing paths in the host OS kernel
that have a vulnerability. In the second case, once the attacker has exploited
this type of flaw, the attack program will be able to run arbitrary code, and
therefore can make system calls in the host OS directly. The system we will propose
in Section 4 is designed to prevent both types of attacks.

\noindent\textbf{Threat model.}
To summarize, our threat model makes the following assumptions.

\begin{itemize}\setlength\itemsep{0em}

\item The attacker possesses knowledge about one or more unpatched vulnerabilities in the host OS.

\item The attacker is permitted to execute any code in the secure virtualization system.

\item If the attack program can trigger a vulnerability in any privileged code,
whether in the host OS or the secure virtualization system, the attacker is then able to
compromise the system.

\end{itemize}

\textbf{Exclusion}
It should be noted that we intentionally excluded from our study several existing
solutions for building a virtualization system. These techniques were considered
out of scope, as they have different hardware and software requirements.
Primarily we chose not to include solutions that do not run on a full-fledged
privileged operating system, such as a virtualization system that uses a
bare-metal hypervisor~\cite{Xen-03} or hardware-based virtualization
solution~\cite{IntelVT}. \lois{Previous sentence requires clarification. Should it be
"solutions that do not run on top of a full-fledged..."} These solutions
have substantial dependency on the
underlying hardware, which differs from our proposed model. In addition,
they do not interact with a privileged OS kernel, which makes them too different
in structure and function to directly compare.
\yanyan{I feel this make it sound like "accesses and relies on the OS kernel"
constrains our method.} \lois{See revision}

%Based on our threat model,
To achieve our goals, we need to have a better understanding about how
bugs are triggered by attack programs. It is therefore critical to know where
vulnerabilities are located in an OS kernel. Our first step is to design
a security metric that can quantitatively measure how bugs and vulnerabilities
are distributed in the kernel.
%We present and discuss about it in the following section.
