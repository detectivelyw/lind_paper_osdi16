\section{Related Work}
\label{sec.related_work}

This section summarizes a number of previous security approaches
that aim to ensure the safety of privileged code. %in user space and kernel space.
These approaches include past efforts to better define safety metrics, and to quantify
areas of risk in an OS kernel, key studies in the use of various virtualization 
techniques, as well as background information on technologies incorporated into Lind.

\textbf{Safety metrics for evaluating software risk.}
Quantitatively evaluating the risk of software is the first step towards the design of secure virtualization systems, 
since it provides critical information on where the system is vulnerable and needs most protection. 
Earlier approaches to quantifying risk
in software systems focused on identifying a correlation between 
certain directories or module of the system and the presence of faults. For example,
Palix found that the \texttt{drivers} directory in the Linux kernel contains the
most faults, followed by HAL and \texttt{fs}~\cite{palix2011faults}. Similarly,
Chou~\cite{PittSFIeld} showed that device drivers had
much higher error rates than other parts of the kernel, and are thus more vulnerable.
However, this component-focused approach does not necessarily
provide effective detection and defense against kernel bugs, as our
test of the Chou metric in Section~\ref{sec.metric} attests.

\yiwen{I vote to take out the following paragraph, since the metrics mentioned there 
are not closely related to what we are doing.}

There are other approaches to identifying kernel vulnerabilities, some of
which grew out of research in software engineering (code comprehension
in particular). Alhazmi~\cite{alhazmi2008application}
used metrics like defect density and fault exposure ratio to describe the
vulnerability discovery process. Zimmermann~\cite{zimmermann2010searching}
described metrics like code complexity, and code churn (the total added/modified/
deleted lines of code) to predict vulnerabilities. Kim in~\cite{kim2007vulnerability} analyzed
the correlation between shared code size and shared vulnerabilities in
successive versions of a software system. In~\cite{engler2001bugs} Engler analyzed
system code by static analysis to look for contradictions, such as acquired locks that are
not released. While
these prior approaches can be useful for determining readiness for release, and
evaluating the risk of vulnerability exploitation,
they do not provide insights for secure system design.

Prior work has also examined the evolution of kernel defects. For example,
Ozment~\cite{ozment2006milk} and Li~\cite{li2006have} have
both studied how security issues evolve over
time. Ozment reported a decrease in the rate at which new vulnerabilities
are reported by studying the age of vulnerabilities in OpenBSD.
Li found a decrease in memory-related
bugs, and identified semantic bugs being the dominant root causes.  
% \lois{this sentence about Li says nothing and reads like
% nonsense. He reported an increase in the bugs by studying the number of bugs?
%I checked the paper but had no clue what this referred to}
%\yiwen{I fixed it. Please check.}
However, neither of these approaches provided data
on how vulnerabilities are distributed.
In contrast, guided by its design metric, Lind can assess that the primary locations
of bugs are in the less-used paths.

%Much work has been done in analyzing system faults using techniques in
%software engineering. For example,

\textbf{Design of virtualization systems.}
Different techniques and approaches have been tried in the design of secure virtualization systems. 
Lind incorporates a number of previous virtualization techniques, such as Library OSes. This section details some
of the significant work relevant to the development of Lind.

\textit{System Call Interposition} (SCI) provides
%offers a number of properties that make it attractive to run applications
secure execution of applications by exposing a minimal kernel surface.
This approach usually enforces the userspace policies through a monitor process that
interacts with the system call execution engine
%for building sandboxes, though it can be error prone
\cite{SCI-04}.
Issues in SCI include the difficulty of appropriately replicating OS semantics,
multi-threaded applications that cause race conditions, and indirect paths to resources that are often overlooked.
In addition, system calls that are denied can cause inconsistencies~\cite{Problems-SCI}.
SCI is similar to the Lind isolation mechanism. However, a key difference is the actual execution
of a system call through the Lind's SafePOSIX re-creation to ensure safe POSIX API for the userspace applications.

\textit{Software Fault Isolation} (SFI)
provides sandboxing in which native
instructions can only be executed if they do not violate the sandbox's
constraints \cite{SFI:93}, and security policies are enforced through machine-level
code analysis. In SFI, memory
writes are protected and code jumps cannot access predefined memory of
other programs to execute their code.
Native Client (NaCl) \cite{NaCl-09} is an SFI system for the
Chrome browser that allows native executable code to run directly in a
browser. NaCl prevents suspicious code
from memory corruption or direct access to the underlying system
resources. Lind adopts NaCl as one key component to ensure secure execution 
of binary code. 

\textit{Language-based virtualization.}
Programming languages like Java, JavaScript, Lua~\cite{Lua}, and
Silverlight~\cite{Silverlight} can provide safety in virtual systems by
``translating" application commands into a native language.
%
Though many sandboxes implement the bulk of standard libraries in
memory-safe languages like Java or C\#, flaws in this code can
still pose a threat~\cite{JavaBugs, Java-Lessons}.
Any bug or failure in a programming language virtual
machine is usually fatal. In contrast, the main component of Lind
is built using Repy, which is a programming language with a very small TCB.
This enhances the security of privileged code due to fewer LOC, \yanyan{should
we mention these fewer LOC are in common paths?} which in
turn reduces the number of potential bugs or weaknesses.
%\lois{OK, what does the TCB have to do with these languages? My
%question still stands. How does the last sentence relate to programming
%languages}
%\yiwen{I think it is fixed now.}

\textit{OS virtualization}
techniques include
bare-metal hardware virtualization, such as VMware ESX Server, Xen,
LXC~\cite{LXC}, BSD's jail, Solaris zones, and Hyper-V, and
hosted hypervisor virtualization such as VMware
Workstation, VMware Server, VirtualPC and VirtualBox.
Security by isolation \cite{Qubes, Overshadow, SecureVM, HypSec}
provides safe executing environments through containment for multiple
user-level virtual environments sharing the same hardware.
However, there are limitations of this approach due to
the large attack vectors against the hypervisors, including
vulnerabilities of software and configuration risks. Lind avoids such restrictions due to a smaller TCB.

\textit{Library OSes}
allow applications to efficiently obtain the benefits of virtual machines
by refactoring a traditional OS kernel into an application library.
%\lois{HOW?}
%\yiwen{fixed.}
%including security isolation, host platform compatibility, and
%migration.
%Libra \cite {Libra} is an example of a library OS that allows
%applications to customize their OSs within VMs.
%This solution is similar to the exokernel approach where a small trusted kernel
% is separated from the untrusted libraries
%that function as an abstraction layer between the applications and the underlying hardware.
%Libra utilizes a hypervisor instead of the exokernel to deliver efficient
%portability and performance. \lois{Ok..so what is the connection}
%
Drawbridge \cite{Drawbridge-11} is a library OS that uses picoprocesses
(lightweight containers), a security monitor (to enforce rules),
and a library OS to present a Windows persona for %a wide variety of
Windows applications. Similar to Lind,
it restricts access from usermode to host OS through a number
of operations that pass through the security monitor.
%\lois{How does this fit with Lind?}
%
%This approach brings many of the benefits of VM based temporal,
%spatial and fault isolation properties to a per-process level.
%
Bascule \cite{Bascule}, an architecture for library OS extensions
based on Drawbridge, allows application behavior to be customized by
extensions loaded at runtime.
Graphene \cite{Graphene-14} is a library OS system that
executes both single and
multi-process applications with low performance overheads.
%It broadens the library OS paradigm to support secure, multi-process
%APIs, such as copy-on-write fork, signals, and System V IPC.
Haven \cite{Haven} uses a library OS to implement
shielded execution of unmodified server applications
in an untrusted cloud host.
%Haven leverages the hardware protection of
%Intel SGX to defend against
%privileged code and physical attacks, such as memory probes, but also
%addresses the dual challenges of
%executing unmodified legacy binaries and protecting them from a
%malicious host.

While library OSes rely extensively on
the underlying kernels to perform system functions,
Lind reimplements complex OS functions through memory-safe Repy
code, relying on only a limited set of system functions from the Repy
sandbox. Unlike Lind, Drawbridge, Bascule or Haven
do not have the sandbox environment that properly contains
buggy or malicious behavior, and therefore could allow attackers
to trigger zero-day vulnerabilities in the underlying kernel.