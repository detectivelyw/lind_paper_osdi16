\section{Implementation of Lind}
\label{sec.implementation}

To test our Lock-in-Pop design, we used it to implement a secure virtual machine
called Lind\footnote{\scriptsize An old English word for a shield constructed from two layers of
linden wood, providing strength in a lightweight form, the name is appropriate for
a virtual machine that adapts two technologies\textendash
yet still protects vulnerable OS kernel code from exploitation by
untrusted user programs.}. 
Lock-in-Pop utilizes a
computational module and a library OS. In Lind, Native Client (NaCl) serves as the former,
while Restricted Python (Repy), and a POSIX interface built into it, performs the task of the latter.
We present a brief description of these components and how they were integrated
into Lind, followed by a brief example of how the system works.

\subsection{Primary Components}

\textbf{Native Client.}
We use NaCl to isolate the computation of the user application
from the kernel. NaCl allows Lind to work on most types of legacy code.
It compiles the programs to produce a binary with software fault isolation.
This prevents the majority of the application from performing system calls
or executing arbitrary instructions.
To perform a system call, the application will call into a small privileged
part of the NaCl TCB that forwards system calls, usually to the OS for
processing. To build Lind, we changed the NaCl TCP to
forward these calls to the library OS that we call SafePOSIX (details below).

\textbf{Seattle's Repy.}
To build an API to access the safe parts of the underlying kernel, we need
two things. First, we need a restricted sandbox that isolates computation
and only allows access to commonly used kernel paths.  We used
Seattle's Repy~\cite{Repy-10} sandbox to perform this task.
Second, to serve the user programs, there has to be an operating system interface that 
provide system functions. We chose the widely accepted standard POSIX interface. 
To enforce isolation, we need to build our POSIX implementation to run within that sandbox.

\textit{The Repy Sandbox Kernel.}
As the only piece of code in contact with the system call paths of the TCB,
the sandbox kernel's security is of paramount concern.
We used Seattle's Repy system API due to its tiny sandbox kernel
(comprised of around 8K LOC), and its ability to provide straightforward
access to the minimal set of the system call API needed to build general
computational functionality. Repy allows
access only to the safe portions of the OS kernel with 33 basic API
functions, including 13 network functions, 6 file functions, 6 threading functions,
and 8 miscellaneous functions~\cite{Repy-10, RepyKernel}. The code is
written using style guidelines designed to ease security auditing
 of the code~\cite{style}. Most of these functions are simple and
regularly used system calls that access the commonly used kernel paths.

The Repy kernel code provides a solid foundation for our secure virtual
machine. It has been audited by a professional penetration tester and, since 2010,
there has also been a bug bounty program for security flaws in the sandbox.
The code is deployed in daily use across thousands of devices,
including on the Seattle testbed \cite{seattle}, and has been examined by
hundreds of parties. To date no security flaws have been found in the sandbox
kernel. Having a small, easily auditable piece of code thus helps to reduce the
risk of such occurrence.

However, Lind's security does not rely solely on Repy's
safety record. A reconfigured POSIX interface, and the isolation of
the NaCl module within the dual sandbox design enhance the protection it can
provide.

\subsection{Enhanced Safety in Call Handling}

The kernel interface is extremely rich and hard to protect.
The dual sandbox Lock-in-Pop design used to build Lind provides enhanced
safety protection through both isolation and a POSIX interface that
reformulates risky system calls to
provide sufficient API for legacy applications, with minimal impact on the kernel.

\textbf{An example system call execution.}
In Lind, a system call issued from user code is
received by NaCl, and then redirected to our system API module, which
includes a POSIX API to serve those requests. A POSIX API is a set of standard
operating system interfaces that provide
necessary operating functionalities. A standard POSIX API is large and complex,
making it difficult to ensure its implementation is secure and bug-free.
Lind takes advantage of the fact that Repy is a programming language sandbox to
construct a variation on the POSIX API. Following the
Lock-in-Pop design, to service a system call in NaCl, a server routine in
Lind marshals its arguments into a text string, and sends the call and the arguments
to the Repy sandbox, where the "reimplemented" system call, marshals the result and
returns it back to NaCl. Eventually, the result is returned as the appropriate
native type to the calling program.

Using the file system API in Lock-in-Pop as an example, it only needs
to provide functionality of writing data to storage. 
%\yanyan{why only discuss file system?
%how about network, threading, etc?}
%\yiwen{threading is done by the OS kernel directly, no reconstruction to discuss. 
%And our network functions are really simple, things like opening and closing a socket is 
%not very exciting.}
It eliminates the need of having a direct abstraction, the
concept of file permissions, links, or even the concept of multiple files.
The system API safe reimplementation is a set of more complicated system calls
derived from functions in the sandbox kernel.
We reimplement those system calls because we do not want this potentially risky user code
to have direct access to the underlying OS kernel.
Instead, our reimplementation layer serves as a mediator between the user code
and the OS kernel. The reimplementation is safe
because the reconstructed calls are isolated in a sandbox, and the code for the
reimplementation is written in a memory-safe programming language.

Here is an example of how this reimplementation would work with the symbolic link function.
If there is a bug in this function, rather than rely on the kernel code paths
for symbolic links, Lind implements the incorrect behavior, such as creating a symbolic link 
with a deleted file. 
This denies the code the privileged access to the system the OS kernel does.
As a result, instead of creating a security issue, the application is denied access
to the file system.

Our design could include more than two sandboxes, e.g., by sandboxing the sandbox
kernel. However, in a secure system,
the sandbox at the lowest level must have the fundamental,
even if limited, access to system resources, such as memory, and storage, threads.
Even if we were to sandbox the sandbox kernel, 
%and have additional sandboxes,
the one at the lowest level will still access the OS kernel in a similar way.
Thus, having multiple sandboxes does not provide extra security benefits.